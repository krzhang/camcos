from typing import List,Optional
from abc import ABC,abstractmethod
import numpy as np
import random
from scipy import stats
from constants import MAX_LIMIT, INFTY
from settings import DATA_PATH
import pandas as pd
from bisect import bisect

class ResourcePackage(ABC):
    """
    Super class of multiple resources. Generate function should return a dictionary of {resource:[values]}. This can be passed in to Demand and Simulator class
    """
    def __init__(self,resource_names: List,resource_behavior,capped: bool):
        """
        Default Constructor
        :param resource_names: Take in a list of resources. Converts everything to string so we can also pass in class BasicResource
        :param resource_behavior: INDEPENDENT, CORRELATED, INDIVIDUAL or JOINT
        :param capped: True for X+Y=Z method. False for X+Y method
        """
        self.resource_names = [str(x) for x in resource_names]
        self.dimension = len(self.resource_names)
        self.resource_behavior = resource_behavior
        self.capped = capped

    @abstractmethod
    def generate(self):
        """
        Child class must override this function and return a dictionary of {resource:value}
        """
        pass

class Independent_Resources(ResourcePackage):
    """
    Child class of ResourcePackage. Resources are generated by generating one number and splitting it n-ways randomly
    """
    def __init__(self,resource_names: List[str],ratio: List[int],basefee_max_limit,alpha=1.42150,beta=21000):
        """
        Default Constructor
        :param resource_names: List of resource names
        :param ratio: An array of ratios. Eg: (0.7, 0.3) would split the resource into 2 basefees with those relative
        values. But it doesn't matter much here since the ratios will be randomized to produce uncorrelated resources
        :param basefee_max_limit: Maximum value it can take
        :param alpha: Alpha value for pareto distribution
        :param beta: Beta value for pareto distribution
        """
        super().__init__(resource_names,"INDEPENDENT",True)
        assert(sum(ratio)==1)
        self.ratio = {resource_names[i]: ratio[i] for i in range(self.dimension)}
        self.basefee_max_limit = {resource_names[i]: ratio[i]*basefee_max_limit for i in range(self.dimension)}
        # pareto distribution with alpha 1.42150, beta 21000 (from empirical results)
        self.alpha = alpha
        self.beta = beta

    def generate(self):
        # Generate 1 number
        _limits_sample = (np.random.pareto(self.alpha, 1) + 1) * self.beta
        _limits_sample = min(_limits_sample[0], MAX_LIMIT)

        # Twiddle ratio code
        new_ratios = {x: random.uniform(0.0, self.ratio[x]) for x in self.ratio}
        normalization = sum(new_ratios[x] for x in new_ratios)
        newer_ratios = {x: new_ratios[x] / normalization for x in self.ratio}

        limits = {r:min(_limits_sample * newer_ratios[r], self.basefee_max_limit[r]) for r in self.resource_names}
        return limits

class Correlated_Resources(ResourcePackage):
    """
    Child class of ResourcePackage. Resources are generated by generating one number and splitting it with the given ratio
    """
    def __init__(self,resource_names: List[str],ratio: List[int],basefee_max_limit,alpha=1.42150,beta=21000):
        """
        Default Constructor
        :param resource_names: List of resource names
        :param ratio: An array of ratios. Eg: (0.7, 0.3) would split the resource into 2 basefees with those relative
        values.
        :param basefee_max_limit: Maximum value it can take
        :param alpha: Alpha value for pareto distribution
        :param beta: Beta value for pareto distribution
        """
        super().__init__(resource_names,"CORRELATED",True)
        self.ratio = {resource_names[i]: ratio[i] for i in range(self.dimension)}
        self.basefee_max_limit = {resource_names[i]: ratio[i]*basefee_max_limit for i in range(self.dimension)}
        # pareto distribution with alpha 1.42150, beta 21000 (from empirical results)
        self.alpha = alpha
        self.beta = beta

    def generate(self):
        _limits_sample = (np.random.pareto(self.alpha, 1) + 1) * self.beta
        _limits_sample = min(_limits_sample[0], MAX_LIMIT)

        limits = {r:min(_limits_sample * self.ratio[r], self.basefee_max_limit[r]) for r in self.resource_names}
        return limits

# This is for the X+Y method of doing resources instead of Z=X+Y
class BasicResource(ABC):
    """
    Class for creating a singular resource profile. Super class for individual resources that generate their own values.
    Adam's old code from TxSimulations.ipynb
    """
    def __init__(self, name,basefee_limit = None):
        """
        Default Constructor
        :param name: Name of the resource
        :param basefee_limit: Maximum limit it can take. Off by default
        """
        self.name = name
        self.basefee_limit = basefee_limit

    @abstractmethod
    def generate(self):
        """
        Child class must override generate function
        """
        pass

    def __str__(self):
        """
        Ensures that an array of BasicResource can be passed into ResourcePackage by converting it into string when
        str() is called
        :return: Name of resource
        """
        return self.name

class BasicCallData(BasicResource):
    def __init__(self,alpha = 0.1581326153189052,beta = 0.0003219091599014724,proportionLimit=None,lowerLimit = None,basefee_max=None):
        """
        Child class from BasicResource
        :param alpha, beta: Found values from TxSimulations.ipynb
        :param proportionLimit: If given, when random number generator is less than this number, lowerLimit will be generated
        :param lowerLimit: lowest default value
        :param basefee_max: max value
        """
        super().__init__("call_data")
        self.alpha = alpha
        self.beta = beta
        self.proportionLimit = proportionLimit
        self.lowerLimit = lowerLimit
        self.basefee_max = basefee_max
    def generate(self):
        if self.proportionLimit is None:
            if self.basefee_max is None:
                return float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1))
            else:
                return min(float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1)),self.basefee_max)
        else:
            ran = random.uniform(0, 1)
            # ran2=random.uniform(0,1) #dont want to make mixture model for call data with 0s
            if ran < self.proportionLimit:
                return self.lowerLimit
            else:
                if self.basefee_max is None:
                    return float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1))
                else:
                    return min(float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1)), self.basefee_max)

class BasicGas(BasicResource):
    def __init__(self,alpha = 0.7419320005030383,beta = 3.945088386120236e-06,proportionLimit=0.1833810888252149,lowerLimit = 21000,basefee_max=None):
        super().__init__("gas")
        self.alpha = alpha
        self.beta = beta
        self.proportionLimit = proportionLimit
        self.lowerLimit = lowerLimit
        self.basefee_max = basefee_max

    def generate(self):
        if self.proportionLimit is None:
            if self.basefee_max is not None:
                return float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1))
            else:
                return min(float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1)), self.basefee_max)
        else:
            ran = random.uniform(0, 1)
            # ran2=random.uniform(0,1) #dont want to make mixture model for call data with 0s
            if ran < self.proportionLimit:
                return self.lowerLimit
            else:
                if self.basefee_max is None:
                    return float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1))
                else:
                    return min(float(stats.gamma.rvs(self.alpha, scale=1 / self.beta, size=1)), self.basefee_max)

class Individual_Resources(ResourcePackage):
    """
    Takes in an array of BasicResource so that we can generate values with X+Y method
    """
    def __init__(self,resource_names: List[BasicResource]):
        self.resource_package = resource_names
        super().__init__(resource_names,"INDIVIDUAL",False)

    def generate(self):
        """
        Calls generate function for each BasicResource
        :return:
        """
        limits = {str(r):r.generate() for r in self.resource_package}
        return limits

class Joint_Resources(ResourcePackage):
    """
    Adam's code. Reads in csv from
    """

    def __init__(self,resource_names: List[str]):
        # self.resource_package = resource_names
        self.resource_package = ["gas","call_data"]
        super().__init__(self.resource_package,"JOINT",False)

    def generate(self):
        df = pd.read_csv(str(DATA_PATH)+"/specialGeneration.csv")
        rand = random.random()
        ### Temporary solution to the blue cluster from Adam's code
        if rand>= 0.801803:
            gas = 30000
            call_data = 136
            return {"gas": gas, "call_data": int(call_data)}
        ###

        index = bisect(df["Additive Ratio"],rand)
        print(rand, index)
        gas = df["Gas Value"][index]
        call_data = df["Call Data Length"][index]
        if np.isnan(gas):
            gas = float(stats.gamma.rvs(df["Alpha Gamma Parameter"][index], scale=1 /df["Beta Gamma Parameter"][index] , size=1))
        if np.isnan(call_data):
            call_data = float(stats.gamma.rvs(df["Alpha Gamma Parameter"][index], scale=1 /df["Beta Gamma Parameter"][index] , size=1))
        return {"gas":gas,"call_data":int(call_data)}
